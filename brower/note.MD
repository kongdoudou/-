用户输入url地址（如果只是输入关键字，浏览器会生成默认的访问地址）会开始导航，这个步骤在浏览器进程里面做
浏览器进程会准备一个渲染进程用于渲染页面
网络进程加载资源，最终将加载的资源交给渲染进程来处理
渲染完毕显示

## 网络分层模型
网络七层模型：物理层 数据链路层 网络层 传输层 会话层 表示层 应用层  
> (会话层 表示层 应用层) -- 应用层，代表协议：HTTP、DNS
>- DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。 
>- DNS是域名分层解析，每一级别域名都有单独的域名服务器，从根服务器进行解析的
>- DNS解析是基于UDP的
>- host = IP + 端口

> 传输层 -- 传输层，代表协议TCP（可靠传输、分段传输）、UDP（用户数据报协议，可能丢包，丢包之后重传，一般直播、视频等会采用这种协议）  

> 网络层 -- 网络层，该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机并将数据包传送给对方，代表协议：IP；
>- 在网络层会增加作为通信目的地的MAC地址然后转发给链路层  
>- IP协议的作用是把各种数据包传送给对方，而要保证确实传送给对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址
>- IP间的通信依赖MAC地址，在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标，这时候会采用ARP协议
>- ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址
    
>（物理层、数据链路层）-- 链路层，用来处理网络连接的硬件部分，包括控制操作系统、硬件的设备驱动、网卡以及光纤等  
      
利用TCP/IP协议进行数据通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。

1、数据通信是利用以上网络模型进行数据传输的；

2、先去查找缓存，看缓存是否过期，如果没有过期，直接返回缓存中内容  
3、看域名是否被解析过，解析使用的是DNS协议
4、请求如果是HTTPS的，会存在SSL协商，这里存在对称加密和非对称加密
>- 对称加密 - 加密和解密使用同一个秘钥
>- 非对应加密 - 加密使用公钥、解密使用私钥，且私钥各自保管
5、IP地址来进行寻址，排队等待，最多同时可以发送6条HTTP请求
6、用TCP协议创建连接（三次握手，SYN\ACK，四次断开），用于传输
7、利用TCP传输数据（拆分成数据包、有序），TCP是可靠的，有序的，服务端会按照顺序进行接收
8、HTTP请求（请求头、请求行、请求体）
9、http1.1 默认链接不会断开（keep-alive），下次传输数据的时候可以复用这个连接
10、服务端接收数据后，进行响应（响应行、响应头、响应体）
11、服务端返回301、302会进行重定向 
12、服务端返回304会查询浏览器缓存进行返回


### HTTP协议
http0.9 只能传输html，没有请求头和响应头
http1.0 提供了http的header，可以根据header的不同来处理不同的资源
http1.1 默认开启了长链接（keep-alive）,链路复用，管线化（串行连接，存在队头阻塞问题）
http2.0 多路复用（并行，解决管线化导致的队头阻塞），只开启一条TCP连接，头部压缩，服务端可以推送数据到客户端
http3.0 解决了TCP协议的队头阻塞的问题，采用UDP+QUIC协议来进行连接的建立




### HTTP的缺点
#### 通信使用明文可能会被窃听
>- HTTP本身不具备加密的功能，所以无法做到对通信整体（请求和响应的内容）进行加密，所以HTTP报文使用明文方式发送
>- 通信内容在所有的通信线路上都有可能遭到窥视。
>- 窃听相同网段上的通信并非难事，只需要借助抓包工具收集在互联网上流动的数据包就可以了。
>- 加密以及未加密的报文都可以被抓到，只是如果抓到的加密之后的报文有可能无法进行破解。

> 加密的对象
>- 通信的加密，通过与SSL（安全套接层）或TLS（安全传输层协议）的组合使用，加密HTTP的通信内容。-- 也就是在这条安全的通信线路上进行HTTP通信，也就是HTTPS
>- 内容的加密，对HTTP报文里包含的内容进行加密处理。为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制，主要应用在web服务中。-- 此种方式由于么有将通信线路进行加密，所以内容仍然存在被篡改的风险。

#### 不验证通信方的身份就可能遭遇伪装
> HTTP协议中的请求和响应不会对通信方进行确认，也就是说存在“服务端是否就是发送请求中URL真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。
> `任何人都可以发起请求`  
> 1、在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求，另外服务端只要接收到请求，不管对方是谁都会返回一个响应 -- 如果web服务器限制了发送端的IP和端口号的情况除外  
> 存在的隐患
>- 无法确认服务器是不是真实的服务器，有可能是伪造的；
>- 无法确认客户端是不是真正发起请求的客户端，有可能是伪造的；
>- 无法确认通信双方是否具备访问权限，因为某些web服务器上保存着重要的信息，只想发给特定的用户；
>- 无法判定请求来自何方、出自谁手；
>- 即使是无意义的请求也会照单全收，无法阻止海量请求下的Dos攻击。

`查明对手的证书`
> SSL不仅提供加密处理，而且还使用了一种被称为证书的手段
> 证书由值得信任的第三方机构进行颁发，用以证明客户端和服务端是真实存在的。  
> 客户端在开始通信之前先确认服务器的证书，也就是确认通信线路是否是安全链接的，如果是不安全的那么存在个人信息泄露的风险 -- chrome浏览器不安全的例子
> 客户端持有证书即可完成个人身份的验证，也可以用于对web网站的认证环节。

#### 无法验证报文完整性，可能已被篡改

### HTTP+加密+认证+完整性保护=HTTPS
#### HTTP + 通信加密 + 认证 + 完整性保护 = HTTPS
> 把添加了加密及认证机制的HTTP称为HTTPS  
> 证书可证明客户端和服务器双方的身份
#### HTTPS是身披SSL外壳的HTTP
> HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL/TLS协议代替而已  
> 通常，HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了
> 简而言之，所以HTTPS，其实就是身披SSL协议这层外层的HTTP。  
> 在采用SSL之后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能了  
> SSL是独立于HTTP的协议，可以说是目前世界上应用最为广泛为网络安全技术。

https://zhuanlan.zhihu.com/p/27395037

## 网络优化策略
减少HTTP请求，合并css、js文件，合理使用内联的css、js
合理使用服务端缓存，强制缓存（expires、cache-control：max-age=10）、协商缓存（last-modified/last-modifify-slice、Etag/if-none-match）
文件的压缩 -- `webpack怎么压缩？`
服务端压缩：GZIP content-encoding:gzip，压缩的内容包括html、css、js
域名分片技术，将资源分布在不同的域名上，绕过一个域名最多只能有6条TCP连接的限制
采用CDN加快访问速度
预加载，首页使用的文件添加属性preload，其他非首页的文件添加属性prefetch
> preload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，需要执行时再执行  
> <link rel="preload" href="/path/to/style.css" as="style">
> <link rel="preload" href="./app.js" as="script">  
> <link rel="prefetch" href="/path/to/style.css">
> <link rel="prefetch" href="./category.js">  
> 对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch
> 使用 preload 和 prefetch 的逻辑可能不是写到一起，但一旦发生对用一资源 preload 或 prefetch 的话，会带来双倍的网络请求

采用dns-prefetch进行dns预解析   　
> 1、用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv="x-dns-prefetch-control" content="on" />  
> 2、在页面header中使用link标签来强制对DNS预解析: <link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />`  
避免使用重定向 301 302，重定向会降低响应速度


## 关键渲染路径
重排（回流 reflow）：添加元素、修改元素大小及位置、获取位置相关信息、删除元素、都会触发回流（在layout阶段）
重绘（repaint）：页面中元素样式的改变并不会影响它在文档流中的位置

